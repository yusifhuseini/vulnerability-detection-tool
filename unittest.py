import nmap, paramiko, ftplib
import telnetlib3, logging, subprocess

# Logging setup
logging.basicConfig(filename='detection_tool_scan.log', level=logging.ERROR, format='%(asctime)s - %(levelname)s - %(message)s')

# Port Scanning Function
def port_scan(target):
    nm = nmap.PortScanner()
    try:
        nm.scan(target, '1-1024', '-A')
        scan_results = []
        for host in nm.all_hosts():
            for proto in nm[host].all_protocols():
                for port in nm[host][proto]:
                    state = nm[host][proto][port]['state']
                    service = nm[host][proto][port]['name']
                    version = nm[host][proto][port].get('version', '')
                    product = nm[host][proto][port].get('product', '')
                    extra_info = nm[host][proto][port].get('extrainfo', '')
                    output = f"{port}/tcp {state} {service} {product} {version} {extra_info}".strip()
                    scan_results.append(output)
        return scan_results
    except nmap.PortScannerError as e:
        logging.error(f"Nmap Error: {e}")
        return []  # Return empty list to handle the error gracefully

# SSH Brute Force Function
def ssh_brute_force(target, username, password_list, result_callback):
    ssh = paramiko.SSHClient()
    ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
    for password in password_list:
        try:
            result_callback(f"Trying password: {password}")
            ssh.connect(target, username=username, password=password)
            result_callback(f"Password found: {password}")
            return password
        except paramiko.AuthenticationException:
            result_callback(f"Authentication failed for password: {password}")
            continue
        except paramiko.SSHException as e:
            result_callback(f"SSH Exception: {e}")
            continue
    return None

# FTP Brute Force Function
def ftp_brute_force(target, username, password_list, result_callback):
    for password in password_list:
        try:
            result_callback(f"Trying password: {password}")
            with ftplib.FTP(target) as ftp:
                ftp.login(user=username, passwd=password)
            result_callback(f"Password found: {password}")
            return password
        except ftplib.all_errors:
            result_callback(f"Authentication failed for password: {password}")
            continue
    return None

# Telnet Brute Force Function with telnetlib3
async def telnet_brute_force(target, username, password_list, result_callback):
    async def try_password(target, username, password):
        writer = None
        try:
            result_callback(f"Trying password: {password}")
            reader, writer = await telnetlib3.open_connection(target, 23)
            login_prompt = await reader.read(100)
            while "login:" not in login_prompt:
                login_prompt += await reader.read(100)
            writer.write(username + '\r\n')
            password_prompt = await reader.read(100)
            while "Password:" not in password_prompt:
                password_prompt += await reader.read(100)
            writer.write(password + '\r\n')
            result = await reader.read(100)
            while not any(x in result for x in ["incorrect", "$"]):
                result += await reader.read(100)
            if "incorrect" not in result:
                result_callback(f"Password found: {password}")
                return password
        except (ConnectionRefusedError, OSError) as e:
            result_callback(f"Error: {e}")
        except Exception as e:
            result_callback(f"Unexpected error: {e}")
        finally:
            if writer:
                writer.close()
                try:
                    await writer.drain()
                except Exception:
                    pass
        return None
    for password in password_list:
        found_password = await try_password(target, username, password)
        if found_password:
            return found_password
    return None

# Directory Scanning Function
def directory_scan(target, wordlist=None):
    discovered_paths = []
    dirsearch_cmd = f"dirsearch -u http://{target}"
    if wordlist:
        dirsearch_cmd += f" -w {wordlist}"
    try:
        output = subprocess.check_output(dirsearch_cmd, shell=True, stderr=subprocess.STDOUT, universal_newlines=True)
        lines = output.strip().split('\n')
        for line in lines:
            if line.startswith("["):
                path = line.split()[1]
                discovered_paths.append(f"http://{target}/{path}")
    except subprocess.CalledProcessError as e:
        logging.error(f"Error executing dirsearch: {e}")
        logging.error(f"Command output: {e.output}")
    return discovered_paths

